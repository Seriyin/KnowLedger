package org.knowledger.ledger.crypto.hash

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.cbor.Cbor
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.knowledger.ledger.core.data.hash.Hasher
import org.knowledger.ledger.crypto.Hash
import org.knowledger.ledger.crypto.Hashers
import org.knowledger.ledger.crypto.hash.Hashers.Blake2b256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Blake2b512Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Blake2s256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Haraka256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Haraka512Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Keccak256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.Keccak512Hasher
import org.knowledger.ledger.crypto.hash.Hashers.SHA256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.SHA3256Hasher
import org.knowledger.ledger.crypto.hash.Hashers.SHA3512Hasher
import org.knowledger.ledger.crypto.hash.Hashers.SHA512Hasher
import org.knowledger.ledger.crypto.serial.HashAlgorithmSerializer
import java.security.MessageDigest
import java.security.Security

/**
 * Hashers is a class hierarchy for implementations of
 * common digest algorithms. Out-of-the-box support for:
 * 1. 256-bit SHA3 -> [SHA3256Hasher]
 * 2. 512-bit SHA3 -> [SHA3512Hasher]
 * 3. 256-bit Haraka -> [Haraka256Hasher]
 * 4. 512-bit Haraka -> [Haraka512Hasher]
 * 5. 256-bit Blake2b -> [Blake2b256Hasher]
 * 6. 512-bit Blake2b -> [Blake2b512Hasher]
 * 7. 256-bit Blake2s -> [Blake2s256Hasher]
 * 8. 256-bit SHA2 -> [SHA256Hasher]
 * 9. 512-bit SHA2 -> [SHA512Hasher]
 * 10. 256-bit custom Keccak as per BouncyCastle's
 * custom Keccak parameters -> [Keccak256Hasher]
 * 11. 512-bit custom Keccak as per BouncyCastle's
 * custom Keccak parameters -> [Keccak512Hasher]
 */
@Serializable(HashAlgorithmSerializer::class)
sealed class Hashers(val algorithmTag: String) : Hasher {
    val digester: MessageDigest by lazy { MessageDigest.getInstance(algorithmTag) }

    @OptIn(ExperimentalSerializationApi::class)
    override val id: Hash by lazy {
        applyHash(Cbor.encodeToByteArray(HashAlgorithmSerializer, this))
    }


    override fun applyHash(input: ByteArray): Hash =
        Hash(digester.digest(input))


    override val hashSize: Int by lazy { digester.digestLength }

    private fun checkAlgorithm(digestLength: Int, algorithm: String): Boolean =
        digestLength == hashSize && algorithm == algorithmTag


    object SHA3256Hasher : Hashers("SHA3-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object SHA3512Hasher : Hashers("SHA3-512") {
        override val hashSize = BYTE_SIZE_512
    }

    object Haraka256Hasher : Hashers("HARAKA-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object Haraka512Hasher : Hashers("HARAKA-512") {
        override val hashSize = BYTE_SIZE_512
    }

    object Blake2b256Hasher : Hashers("BLAKE2B-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object Blake2b512Hasher : Hashers("BLAKE2B-512") {
        override val hashSize = BYTE_SIZE_512
    }

    object Blake2s256Hasher : Hashers("BLAKE2S-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object SHA256Hasher : Hashers("SHA-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object SHA512Hasher : Hashers("SHA-512") {
        override val hashSize = BYTE_SIZE_512
    }

    object Keccak256Hasher : Hashers("KECCAK-256") {
        override val hashSize = BYTE_SIZE_256
    }

    object Keccak512Hasher : Hashers("KECCAK-512") {
        override val hashSize = BYTE_SIZE_512
    }


    companion object {
        private const val BYTE_SIZE_512 = 64
        private const val BYTE_SIZE_256 = 32
        val DEFAULT_HASHER = Blake2b256Hasher

        init {
            //Ensure Bouncy Castle Crypto provider is present
            if (Security.getProvider("BC") == null) {
                Security.addProvider(BouncyCastleProvider())
            }
        }

        /**
         * Returns the [Hashers] instance which matches the supplied
         * [hash] with the one generated by hashing its own contents.
         *
         * Throws [NoSuchHasherRegistered] if no matching [Hashers]
         * instance is present.
         */
        fun getHasher(hash: Hash): Hashers = when {
            SHA3256Hasher.checkForHasher(hash) -> SHA3256Hasher
            SHA3512Hasher.checkForHasher(hash) -> SHA3512Hasher
            Haraka256Hasher.checkForHasher(hash) -> Haraka256Hasher
            Haraka512Hasher.checkForHasher(hash) -> Haraka512Hasher
            Blake2b256Hasher.checkForHasher(hash) -> Blake2b256Hasher
            Blake2b512Hasher.checkForHasher(hash) -> Blake2b512Hasher
            Blake2s256Hasher.checkForHasher(hash) -> Blake2s256Hasher
            SHA256Hasher.checkForHasher(hash) -> SHA256Hasher
            SHA512Hasher.checkForHasher(hash) -> SHA512Hasher
            Keccak256Hasher.checkForHasher(hash) -> Keccak256Hasher
            Keccak512Hasher.checkForHasher(hash) -> Keccak512Hasher
            else -> throw NoSuchHasherRegistered(hash)
        }

        /**
         * Checks one of the available algorithms matches
         * the provided parameters.
         * Returns the digest algorithm class from [Hashers]
         * implementers, if one such exists, that explicitly
         * matches in [digestLength] and [algorithm] tag.
         */
        fun checkAlgorithms(digestLength: Int, algorithm: String): Hashers? =
            arrayOf(
                SHA256Hasher, SHA512Hasher, SHA3256Hasher, SHA3512Hasher,
                Haraka256Hasher, Haraka512Hasher, Blake2b256Hasher, Blake2b512Hasher,
                Blake2s256Hasher, Keccak256Hasher, Keccak512Hasher
            ).find { it.checkAlgorithm(digestLength, algorithm) }
    }
}